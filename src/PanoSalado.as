package {	import flash.net.URLLoader;	import flash.net.URLRequest;	import flash.net.URLLoaderDataFormat;		import br.com.stimuli.loading.BulkLoader;	import br.com.stimuli.loading.BulkProgressEvent;	import br.com.stimuli.loading.BulkErrorEvent;		import flash.utils.Dictionary;		import flash.display.*;	import flash.text.TextField;	import flash.text.TextFieldAutoSize;	import flash.text.TextFormat;	import flash.display.StageAlign;	import flash.display.StageScaleMode;	import flash.geom.Rectangle;	import flash.events.TimerEvent;	import flash.utils.Timer;	import flash.geom.Point;	//	import zephyr.cameracontrol.CameraController;//	import zephyr.cameracontrol.CameraControllerEvent;	import flash.events.KeyboardEvent;	import flash.ui.Keyboard;		import flash.display.Sprite;	import flash.events.Event;	import flash.events.ProgressEvent;	import flash.events.MouseEvent;	//	import zephyr.cameras.FOVCamera3D;		import org.papervision3d.cameras.Camera3D;	import zephyr.objects.primitives.Cube;	import org.papervision3d.objects.primitives.Plane;	import zephyr.objects.primitives.Sphere;	import org.papervision3d.render.BasicRenderEngine;	import org.papervision3d.scenes.Scene3D;	import org.papervision3d.view.Viewport3D;	import org.papervision3d.events.InteractiveScene3DEvent;	import org.papervision3d.objects.DisplayObject3D;	import org.papervision3d.materials.BitmapMaterial;	import org.papervision3d.materials.utils.MaterialsList;	import org.papervision3d.core.proto.MaterialObject3D;	import org.papervision3d.events.RendererEvent;	import org.papervision3d.core.render.data.RenderStatistics;	import org.papervision3d.core.math.Number3D;	import org.papervision3d.view.layer.ViewportBaseLayer;		//import gs.TweenFilterLite;	import gs.TweenLite;	import zephyr.transitions.None;	import zephyr.transitions.Quad;	import zephyr.transitions.Cubic;	import zephyr.transitions.Quart;	import zephyr.transitions.Quint;	import zephyr.transitions.Sine;	import zephyr.transitions.Circ;	import zephyr.transitions.Expo;	import zephyr.transitions.Elastic;	import zephyr.transitions.Back;	import zephyr.transitions.Bounce;		import zephyr.objects.StageAlignedSprite;	import zephyr.objects.Hotspot;		import org.papervision3d.view.stats.StatsView;	public class PanoSalado extends Sprite	{				public var bulkLoader : BulkLoader;						public var ui:Sprite = new Sprite();				public var spaces:Array = new Array();				public var viewports:Sprite = new Sprite();				//public var cameraController:CameraController;				public var currentSpace:String = "";				public var lastSpace:String = "";				public var loadingSpace:String = "";				private var interactionEquivalents:Object = { mouseClick:"onClick", mouseOver:"onOver", mouseOut:"onOut", mousePress:"onPress", mouseRelease:"onRelease", mouseMove:"onMouseMove", mouseDown:"onPress", mouseUp:"onRelease", click:"onClick" };				private var unclaimedMaterials:Dictionary = new Dictionary(true);				private var _worldDirty:Boolean = false;				public var settings : XML;		//		public var loadMeter:Sprite = new Sprite();				public var resizeDict:Object = new Object();				public function PanoSalado() 		{			addEventListener(Event.ADDED_TO_STAGE, stageReady, false, 0, true);						var xmlLoader:URLLoader = new URLLoader();			xmlLoader.dataFormat = URLLoaderDataFormat.BINARY;			xmlLoader.load( new URLRequest( loaderInfo.parameters.xml?loaderInfo.parameters.xml:"PanoSalado.xml" ) );			xmlLoader.addEventListener(Event.COMPLETE, onXMLLoaded, false, 0, true);						//add viewports sprite to display list.  It will hold all the viewports so they can be iterated/isolated from other items			addChild(viewports);						addEventListener(Event.ENTER_FRAME, doRender, false, 0, true);						//set up bulk loader			bulkLoader = new BulkLoader("bulkLoader");			//			bulkLoader.addEventListener(BulkProgressEvent.PROGRESS, onAllProgress, false, 0, true);			bulkLoader.addEventListener(BulkLoader.COMPLETE, onAllLoaded, false, 0, true);						addChild(ui);			ui.addEventListener(MouseEvent.CLICK, mouseEventHandler, false, 0, true);			ui.addEventListener(MouseEvent.MOUSE_OVER, mouseEventHandler, false, 0, true);			ui.addEventListener(MouseEvent.MOUSE_OUT, mouseEventHandler, false, 0, true);			ui.addEventListener(MouseEvent.MOUSE_DOWN, mouseEventHandler, false, 0, true); 			ui.addEventListener(MouseEvent.MOUSE_UP, mouseEventHandler, false, 0, true); 			ui.addEventListener(MouseEvent.MOUSE_MOVE, mouseEventHandler, false, 0, true); 					}				public function stageReady(e:Event):void		{			stage.align = StageAlign.TOP_LEFT;			stage.scaleMode = StageScaleMode.NO_SCALE;			stage.frameRate = 24;			stage.quality = StageQuality.HIGH						//loadMeter.graphics.beginFill(0xFFFFFF);			//loadMeter.graphics.drawRect(0,0,stage.stageWidth,3);			//loadMeter.graphics.endFill();			//loadMeter.scaleX = 0;			//addChild(loadMeter);		}				private function onXMLLoaded(e:Event):void		{			settings = XML(e.target.data);						initCameraController( stringToBoolean(settings.spaces.@autorotator) || true, int(settings.spaces.@autorotatorDelay) || 15000 );						refresh();						//onStart code hook, pass second arg false to NOT check for onStart in non-existent current scene node.			XMLCodeHook("onStart", false);					}				private function refresh():void		{			sensitivity = 	findValueInXML("cameraSensitivity", Number, 	60);			friction = 		findValueInXML("cameraFriction", Number, 0.3);			threshold = 	findValueInXML("cameraRestThreshold", Number, 0.0001);			keyIncrement = 	findValueInXML("cameraKeyIncrement", Number, 75);			zoomIncrement = findValueInXML("cameraZoomIncrement", Number, 0.2);						maxTilt = findValueInXML("cameraMaximumTilt", Number, 9999);			minTilt = findValueInXML("cameraMinimunTilt", Number, 9999);						maxPan = findValueInXML("cameraMaximumPan", Number, 9999);			minPan = findValueInXML("cameraMinimumPan", Number, 9999);						minZoom = findValueInXML("cameraMinimumZoom", Number, 1);			maxZoom = findValueInXML("cameraMaximumZoom", Number, 50);						dqa = findValueInXML("dynamicQualityAdjustment", Boolean, "true") ;						accSmooth =  findValueInXML("smoothOnAcceleration", Boolean, false );			accPrecise =  findValueInXML("preciseOnAcceleration", Boolean, true );			accPrecision = findValueInXML("precisionOnAcceleration", int, 64);						decSmooth =  findValueInXML("smoothOnDeceleration", Boolean, true );			decPrecise =  findValueInXML("precisionOnDeceleration", Boolean, true );			decPrecision = findValueInXML("precisionOnDeceleration", int, 16);						stopSmooth =  findValueInXML("smoothAtRest", Boolean, true) ;			stopPrecise =  findValueInXML("preciseAtRest", Boolean, true );			stopPrecision = findValueInXML("precisionAtRest", int, 1);						da = findValueInXML("autorotatorIncrement", Number, 0.25);		}				private function onSingleItemLoaded(e:Event):void		{						var bm:BitmapMaterial = new BitmapMaterial( BitmapData(e.target._content.bitmapData) );			unclaimedMaterials[ e.target.url.url.toString() ] = bm ;		}		// 		private function onAllProgress(e : BulkProgressEvent) : void// 		{// 		 	//trace("progress event: loaded" , e.bytesLoaded," of ",  e.bytesTotal);// 		 	loadMeter.scaleX = e.weightPercent;// 		}				private function onAllLoaded(e : BulkProgressEvent) : void		{			trace("PS: " + currentSpace + " has loaded");						lastSpace = currentSpace;						currentSpace = loadingSpace;						loadingSpace = "";						refresh();						// create a new space (viewport, scene, and camera)			var idx:int = instantiateNewSpace();						var thisSpace:Object = spaces[idx];						//set-up camera			setupCamera(thisSpace["camera"], spaces[idx-1]);						//iterate through all the objects in the scene (pano, hotspots, etc)			for each (var xml:XML in findSpaceNode(currentSpace).children() )			{				var nodeName:String = xml.name().localName.toString();								//create papervision primitive by calling the function bearing its name (cube, plane, sphere, etc)				var primitive:Object = root[ nodeName ].call(null, xml);								if ( nodeName != "stageAlignedSprite" )				{					primitive.name = xml.@id.toString();										//set position and rotation of primitive, using += so that it can be pre adjusted e.g. sphere					primitive.x += int(xml.@x) || 0;					primitive.y += int(xml.@y) || 0;					primitive.z += int(xml.@z) || 0;										primitive.rotationX += Number(xml.@rotationX) || 0;					primitive.rotationY += Number(xml.@rotationY) || 0; 					primitive.rotationZ += Number(xml.@rotationZ) || 0; 										primitive.visible = Boolean(xml.@visible) || true;										if ( xml.@onClick != "" ) { primitive.addEventListener(InteractiveScene3DEvent.OBJECT_CLICK, interactionScene3DEventHandler, false, 0, true); }					if ( xml.@onOver != "" ) { primitive.addEventListener(InteractiveScene3DEvent.OBJECT_OVER, interactionScene3DEventHandler, false, 0, true); }					if ( xml.@onOut != "" ) { primitive.addEventListener(InteractiveScene3DEvent.OBJECT_OUT, interactionScene3DEventHandler, false, 0, true); }					if ( xml.@onPress != "" ) { primitive.addEventListener(InteractiveScene3DEvent.OBJECT_PRESS, interactionScene3DEventHandler, false, 0, true); }					if ( xml.@onRelease != "" ) { primitive.addEventListener(InteractiveScene3DEvent.OBJECT_RELEASE, interactionScene3DEventHandler, false, 0, true); }					if ( xml.@onOverMove != "" ) { primitive.addEventListener(InteractiveScene3DEvent.OBJECT_MOVE, interactionScene3DEventHandler, false, 0, true); }										primitive.addEventListener(InteractiveScene3DEvent.OBJECT_OVER, cursorHandler, false, 0, true);					primitive.addEventListener(InteractiveScene3DEvent.OBJECT_OUT, cursorHandler, false, 0, true);										primitive.updateTransform();										thisSpace["scene"].addChild( primitive, xml.@id.toString() );				}				else 				{					ui.addChild( StageAlignedSprite(primitive) );				}			}						//onResize();						bulkLoader.removeAll();						thisSpace["viewport"].interactive = findValueInXML("interactive", Boolean, false);						// add viewport to the displaylist			viewports.addChild( thisSpace["viewport"] );									//transitionStart code hook			XMLCodeHook("onTransitionStart");						//Do transition and transitionEnd code hook			var transArr:Array = findValueInXML("transition", String, "").split(",");			var time:Number = transArr[0] != null ? Number( transArr[0] ) : 3;			var type:String = transArr[1] != null ? transArr[1] : "alpha";			var val:Number = transArr[2] != null ? transArr[2] : 0;			var ease:String = transArr[3] != null ? transArr[3] : "Expo.easeInOutExpo";			var easeArr:Array = ease.split(".");			var easeEq:String = easeArr[0];			var easeFunc:String = easeArr[1];			var initObject:Object = new Object();			initObject.onComplete = XMLCodeHook;			initObject.onCompleteParams = new Array("onTransitionEnd")			initObject.ease = [easeEq][easeFunc];			initObject[type] = val;						TweenLite.from(thisSpace["viewport"], time, initObject );						_worldDirty = true;			//if mouse is not down, cameraController will not be requesting renders onEnterFrame, therefore must call here// 			if ( ! cameraController.enterFrameListenerActive ) // 			{	// 				_worldDirty = true;// 				doRender();// 				// 			}									//code hook			XMLCodeHook("onDisplay");						//remove onDisplay so it doesn't trigger again			settings.@onDisplay = "";					}				private function setupCamera(camera:Camera3D, lastSpace:Object=null):void		{			// set up camera: 			var cameraContinuity:Boolean = findValueInXML("cameraRetainsLastValues", Boolean, false);			var pan:Number = findValueInXML("cameraPan", Number, 0 );			var tilt:Number = findValueInXML("cameraTilt", Number, 0);			var zoom:Number = findValueInXML("cameraZoom", Number, 12);			var focus:Number = findValueInXML("cameraFocus", Number, 100);			var camX:Number = findValueInXML("cameraX", Number, 0);			var camY:Number = findValueInXML("cameraY", Number, 0);			var camZ:Number = findValueInXML("cameraZ", Number, 0);						// leash free or default unspecified leashing			if (!cameraContinuity)			{				camera.rotationX = tilt;				camera.rotationY = pan;				camera.rotationZ = 0;				camera.zoom = zoom;				camera.focus = focus;				camera.x = camX;				camera.y = camY;				camera.z = camZ;				}			else			{				//leash = lock				camera.rotationX = lastSpace != null ? lastSpace["camera"].rotationX : tilt ;				camera.rotationY = lastSpace != null ? lastSpace["camera"].rotationY : pan ;				camera.rotationZ = lastSpace != null ? lastSpace["camera"].rotationZ : 0 ;				camera.zoom = lastSpace != null ? lastSpace["camera"].zoom : zoom ;				camera.focus = lastSpace != null ? lastSpace["camera"].focus : focus ;				camera.x = lastSpace != null ? lastSpace["camera"].x : camX ;				camera.y = lastSpace != null ? lastSpace["camera"].y : camY ;				camera.z = lastSpace != null ? lastSpace["camera"].z : camZ ;			}		}						private function createBitmapMaterial(xml:XML):BitmapMaterial		{			//var material:BitmapMaterial = new BitmapMaterial( bulkLoader.getBitmapData(xml.file.toString(), true) );			var material:BitmapMaterial =  unclaimedMaterials[xml.file.toString()];						material.oneSide = stringToBoolean(xml.@oneSide) || true ;						material.interactive = stringToBoolean( xml.@interactive) || false ;						if ( findValueInXML("dynamicQualityAdjustment", Boolean, true) )				{					material.smooth =  findValueInXML("smoothAtRest", Boolean, true  ) ;										material.precise =  findValueInXML("preciseAtRest", Boolean, true  ) ;									material.precision = findValueInXML("precisionAtRest", int, 1) ;				}			else			{				material.smooth = stringToBoolean( xml.@smooth) || false ;									material.precise = stringToBoolean( xml.@precise) || false ;								material.precision = int( xml.@precision) || 8 ;			}						return material		}				private function sphere(xml:XML):Object		{						var material:BitmapMaterial = createBitmapMaterial(xml);			//var material:BitmapMaterial =  BitmapMaterial(unclaimedMaterials[xml.file.toString()]);						var segments:int = int( xml.@segments) || 9 ;						var radius:int = int( xml.@radius ) || 50000;						var reverse:Boolean = stringToBoolean(xml.@reverse) || true;						var sphere:Sphere = new Sphere(material, radius, segments, segments, reverse );									sphere.rotationY = -50;			sphere.rotationZ = 0;									return sphere;		}				private function cube(xml:XML):Object		{						var materials:MaterialsList = new MaterialsList();						for each (var file:XML in xml.file)			{				var material:BitmapMaterial =  BitmapMaterial(unclaimedMaterials[file.toString()]);								if ( findValueInXML("dynamicQualityAdjustment", Boolean, true) )				{					material.smooth =  findValueInXML("smoothAtRest", Boolean, true  ) ;										material.precise =  findValueInXML("preciseAtRest", Boolean, true  ) ;									material.precision = findValueInXML("precisionAtRest", int, 1) ;				}				else				{					material.smooth = stringToBoolean( xml.@smooth) || false ;											material.precise = stringToBoolean( xml.@precise) || false ;										material.precision = int( xml.@precision) || 8 ;				}								material.oneSide = stringToBoolean( xml.@oneSide) || true ;							material.interactive = stringToBoolean( xml.@interactive) || false ;								materials.addMaterial( material, file.@id.toString() );			}						var insideFaces  :int = Cube.ALL;			var excludeFaces :int = Cube.NONE;						var segments:int = int( xml.@segments) || 9 ;						var width:int = int( xml.@width ) || 100000 ;						var cube:Cube = new Cube( materials, width, width, width, segments, segments, segments, insideFaces, excludeFaces );						return cube;		}				private function hotspot(xml:XML):Object		{			var bmd:BitmapData = bulkLoader.getBitmapData(xml.file.toString(), false);						var width:Number = (2 / bmd.width ) * 40000;						var height:Number = (2 / bmd.height ) * 40000;						var material:BitmapMaterial = createBitmapMaterial(xml);						material.interactive = stringToBoolean( xml.@interactive) || true ;						var segments:int = int( xml.@segments) || 3 ;						var pan:Number = Number( xml.@pan) || 0 ;						var tilt:Number = Number( xml.@tilt) || 0 ; 						var hs:Hotspot = new Hotspot(pan, tilt, material, width, height, segments, segments );						return hs;		}				private function plane(xml:XML):Object		{			var width:Number = int( xml.@width) || 100 ;						var height:Number = int( xml.@height) || 100 ;						var material:BitmapMaterial = createBitmapMaterial(xml);						var segments:int = int( xml.@segments) || 4 ;						var plane:Plane = new Plane( material, width, height, segments, segments );						return plane;		}				private function stageAlignedSprite(xml:XML):Object		{			var bm:BitmapData = bulkLoader.getBitmapData(xml.file.toString(), true);						var sp:StageAlignedSprite = new StageAlignedSprite();						sp.graphics.beginBitmapFill(bm, null, false, false);						sp.graphics.drawRect(0,0,bm.width,bm.height);						sp.graphics.endFill();						sp.scaleX = Number(xml.@scaleX) || 1;						sp.scaleY = Number(xml.@scaleY) || 1;						sp.rotation = Number(xml.@rotation) || 0;						sp.alpha = Number(xml.@alpha) || 1;						sp.visible = stringToBoolean(xml.@visible) || true;						sp.cacheAsBitmap = stringToBoolean(xml.@cacheAsBitmap) || false;						sp.blendMode = String(xml.@blendMode) || "normal";						sp.name = String(xml.@id) || "";						sp.alignment = String(xml.@align) || "tl";						sp.offsetX = Number(xml.@offsetX) || 0;						sp.offsetY = Number(xml.@offsetY) || 0;			//sp.align();			return sp;		}								protected var matsToChange:Array = new Array(),		objsToChange:Array,		numObjsToChange:int,		objToChange:DisplayObject3D,		matToChange:MaterialObject3D,		bmToChange:BitmapMaterial,		dqa:Boolean,		accSmooth:Boolean,		accPrecise:Boolean,		accPrecision:int,		decSmooth:Boolean,		decPrecise:Boolean,		decPrecision:int,		stopSmooth:Boolean,		stopPrecise:Boolean,		stopPrecision:int		;				private function changeQuality(type:String):void		{ 		/* change precise, smooth, and precision while moving camera for better fps		loops through all the scenes in all the spaces, getting all the objects from each, 		and then pushing either the materials from the materialsList, or the material into		an array, and then applies the changes to each item in the array.		*/			if ( dqa )			{				for (var i:int = 0; i < spaces.length; i++)				{					objsToChange = spaces[i]["scene"].objects as Array;					numObjsToChange = objsToChange.length;					for ( var j:int=0; j < numObjsToChange; j++ )					{						objToChange = DisplayObject3D(objsToChange[ j ]);												if (objToChange.materials)						{/// obj.materials is the materialsList, if it is not null add them							for each(  matToChange in objToChange.materials.materialsByName )							{								matsToChange.push(matToChange);							}						}						else 						{// obj.material is the material, add it							matsToChange.push( objToChange.material );						}						while ( matToChange = matsToChange.pop() )						{							if (matToChange is BitmapMaterial)							{								bmToChange = BitmapMaterial(matToChange);								if (type == "accelerating")								{									bmToChange.smooth = accSmooth;									bmToChange.precise = accPrecise;									bmToChange.precision = accPrecision;								}								else if (type == "decelerating")								{									bmToChange.smooth = decSmooth;									bmToChange.precise = decPrecise;									bmToChange.precision = decPrecision;								}								else if (type == "resting")								{									bmToChange.smooth = stopSmooth;									bmToChange.precise = stopPrecise;									bmToChange.precision = stopPrecision;								}							}						}					}				}			}						//_worldDirty is set when camera or objects in scene have changed and need rendering.			_worldDirty = true;		}						protected var dp:Number,		dt:Number,		maxTilt:Number,		minTilt:Number,		maxPan:Number,		minPan:Number,		cam:Camera3D,		newTilt:Number,		newPan:Number,		maxZoom:Number,		minZoom:Number;				private function moveCamera(dp:Number, dt:Number, dz:Number):void		{			for (var i:uint=0; i < spaces.length; i++)			{				var cam:Camera3D = Camera3D(spaces[i]["camera"]);								if (maxTilt == 9999)					maxTilt = 90 + cam.vfov*0.5;				if (minTilt == 9999)					minTilt = -90 - cam.vfov*0.5;								if (dt >= 0)				{					newTilt = cam.rotationX + dt + cam.vfov*0.5;					if (newTilt <= maxTilt)						cam.rotationX += dt;				}				else				{					newTilt = cam.rotationX + dt - cam.vfov*0.5;					if (newTilt >= minTilt)						cam.rotationX += dt;				}								if (dp >= 0)				{					if (maxPan == 9999)						{ cam.rotationY += dp; }					else 					{						newPan = cam.rotationY + dp + cam.hfov*0.5;						if (newPan <= maxPan)							cam.rotationY += dp;					}				}				else				{					if (minPan == 9999)						{ cam.rotationY += dp; }					else 					{						newPan = cam.rotationY + dp - cam.hfov*0.5;						if (newPan >= minPan)							cam.rotationY += dp;					}				}								//zoom 				cam.zoom += dz;				if (cam.zoom < minZoom) { cam.zoom = minZoom }				if (cam.zoom > maxZoom) { cam.zoom = maxZoom }			}						//_worldDirty is set when camera or objects in scene have changed and need rendering.			_worldDirty = true;		}				protected var da:Number;		private function autorotate():void		{			da = findValueInXML("autorotatorIncrement", Number, 0.25);			for (var i:uint=0; i < spaces.length; i++)			{				var cam:Camera3D = Camera3D(spaces[i]["camera"]);				if (da > 0)				{					if (cam.rotationX > da ) { cam.rotationX -= da; }					else if (cam.rotationX < -da ) { cam.rotationX += da; }				}				else				{					if (cam.rotationX < da ) { cam.rotationX -= da; }					else if (cam.rotationX > -da ) { cam.rotationX += da; }				}				cam.rotationY += da;			}			_worldDirty = true;		}				private function doRender(e:Event=null):void		{			/* Check if any of the camera control flags are set and if so move the camera			*/						if (mouseIsDown || keyIsDown)			{				if (keyIsDown)				{					if ( up ) { startPoint.x = stage.mouseX, startPoint.y = stage.mouseY + keyIncrement ; }					if ( down ) { startPoint.x = stage.mouseX, startPoint.y = stage.mouseY - keyIncrement ; }					if ( left) { startPoint.x = stage.mouseX + keyIncrement, startPoint.y = stage.mouseY ; }					if ( right ) { startPoint.x = stage.mouseX - keyIncrement, startPoint.y = stage.mouseY ; }					if ( zoomin ) 					{ 						moveCamera(0, 0, zoomIncrement);												resting = false;					}					if ( zoomout ) 					{ 						moveCamera(0, 0, -zoomIncrement);												resting = false;					}				}				if (mouseIsDown || up || down || left || right)				{					// calculate new position changes					deltaPan = (deltaPan - (((startPoint.x - stage.mouseX) * sensitivity) * 0.00006));					deltaTilt = (deltaTilt + (((startPoint.y - stage.mouseY) * sensitivity) * 0.00006));				}			}			// motion is still over the threshold, so apply friction			if ( ( (deltaPan * deltaPan) + (deltaTilt * deltaTilt) ) > threshold ) 			{				// always apply friction so that motion slows AFTER mouse is up				deltaPan = (deltaPan * (1 - friction) );				deltaTilt = (deltaTilt * (1 - friction) );								moveCamera( deltaPan, deltaTilt, 0);								resting = false;			} 			else 			{ // motion is under threshold stop camera motion				if ( !mouseIsDown && !keyIsDown && !resting)				{						// motion is under threshold, stop and remove enter frame listener					deltaPan = 0;					deltaTilt = 0;										moveCamera(deltaPan, deltaTilt, 0)										changeQuality("resting");										if (_autorotatorOn)						restartAutorotatorTimer();											resting = true;								}			}			if (isAutorotating) autorotate();															// check if anything has set the _worldDirty flag and if so render			if ( _worldDirty )			{				for (var i:int = 0; i < spaces.length; i++)				{					BasicRenderEngine(spaces[i]["renderer"]).renderScene					( 					Scene3D(spaces[i]["scene"]), 					Camera3D(spaces[i]["camera"]), 					Viewport3D(spaces[i]["viewport"]) 					);				}								_worldDirty = false;			}		}								public function cursorHandler(e:InteractiveScene3DEvent=null):void		{			// do nothing		}				private function interactionScene3DEventHandler(e:InteractiveScene3DEvent=null):void		{			var name:String = e.target.name;						trace("PS:" + interactionEquivalents[e.type] + " at " + name );						//execute( settings.child( currentSpace ).children().(attribute('id') == name).attribute( interactionEquivalents[e.type] ).toString() );			execute( settings..*.(hasOwnProperty("@id") && @id == name).attribute( interactionEquivalents[e.type] ).toString() );		}		private function mouseEventHandler(e:MouseEvent=null):void		{			//trace("mouse event", e.target.name, e.type);						var name:String = e.target.name;						//trace("PS:" + interactionEquivalents[e.type] + " at " + name );						execute( settings..*.(hasOwnProperty("@id") && @id == name).attribute( interactionEquivalents[e.type] ).toString() );					}														//functions called by XML code hooks				private function keyDown(direction:String):void		{			trace("PS: go:"+direction);						var e:KeyboardEvent = new KeyboardEvent(KeyboardEvent.KEY_DOWN);						e.keyCode = Keyboard[direction.toUpperCase()]						stage.dispatchEvent(e)		}		private function keyUp(direction:String):void		{						trace("PS: stop:"+direction);						var e:KeyboardEvent = new KeyboardEvent(KeyboardEvent.KEY_UP);						e.keyCode = Keyboard[direction.toUpperCase()]						stage.dispatchEvent(e)		}				private function toggleFullscreen():void		{			switch(stage.displayState) 			{				case "normal":					stage.displayState = "fullScreen";    					break;				case "fullScreen":				default:				stage.displayState = "normal";    					break;			}		}				private function toggleAutorotator():void		{			trace("PS: toggleAutorotator");						if (isAutorotating)			{				autorotatorOn = false;			}			else			{				startAutorotatorNow();			}		}				private function set(str:String):void		{			trace("PS: set: ", str);						var leftSide:String = str.slice(0, str.indexOf("=") );						var rightSide:String = str.slice( str.indexOf("=")+1, str.length );						var leftArray:Array = leftSide.split(".");						var rightArray:Array = rightSide.split(",");						var rightObject:Object = new Object();						for (var i:int=0; i< rightArray.length; i++)			{				var name:String = rightArray[i].slice(0, rightArray[i].indexOf(":") );				var value:String = rightArray[i].slice(rightArray[i].indexOf(":")+1 );								rightObject[name] = value;			}								}				///  This function is deprecated		public function loadSpaceAndInterface(name:String):void		{			trace("PS: loadSpaceAndInterface:"+name); 						if (bulkLoader.isRunning)			{				bulkLoader.removeAll();			}						for each (var xml:XML in findSpaceNode(name).children() )			{				for each (var mat:XML in xml.file)				{					bulkLoader.add(mat.toString(), { type:"image", weight: (mat.@weight || 10) });									if (xml.name().localName.toString() != "bitmap")					{						bulkLoader.get(mat.toString()).addEventListener(Event.COMPLETE, onSingleItemLoaded, false, 100, true);					}				}			}						loadingSpace = name;						bulkLoader.start();					}								public function loadSpace(name:String):void		{			trace("PS: loadSpace:"+name);						if (bulkLoader.isRunning)			{				bulkLoader.removeAll();							}						for each (var mat:XML in findSpaceNode(name)..file)			{ 				bulkLoader.add(mat.toString(), { type:"image", weight: (mat.@weight || 10) });								bulkLoader.get(mat.toString()).addEventListener(Event.COMPLETE, onSingleItemLoaded, false, 100, true)							}						loadingSpace = name;						bulkLoader.start();								}				public function removeLastSpace():void		{			if (viewports.numChildren > 1 )			{				trace("PS: removeLastSpace:"+lastSpace);								viewports.removeChild( viewports.getChildByName( lastSpace ) );								var spaceToRemove:Object = getSpaceByName(lastSpace);								spaceToRemove["viewport"].destroy();								var objects:Array = spaceToRemove["scene"].objects;				var len:int = objects.length;				for ( var j:int=0; j < len; j++ )				{					var obj:DisplayObject3D = objects[ j ];										// objects, e.g. cube with multiple materials have to have materials accessed with a loop on the matList					// IMPROVE so that all objs with MaterialsList do this					if (obj is Cube)					{						for each(  var mo3d:MaterialObject3D in obj.materials.materialsByName )						{							if (mo3d is BitmapMaterial)							{								BitmapMaterial(mo3d).destroy();							}							else { mo3d.destroy(); }						}					}					else					{ // object has only one material accessed this way:						var mat:MaterialObject3D = obj.material;						if (mat is BitmapMaterial)						{							BitmapMaterial(mat).destroy();						}						else { mat.destroy(); }					}										obj = null;				}								spaceToRemove["renderer"].destroy();								spaceToRemove["scene"] = null;								spaceToRemove["camera"] = null;								spaceToRemove["stats"] = null;								// this needs to be improved.  needs to search for the right space by name and splice it out.				// update 7/18: testing needed: this should solve the problem.				spaces.splice(spaces.indexOf(spaceToRemove), 1);								spaceToRemove = null;							}			else trace("PS: removeLastSpace: there is no last space to remove"); 		}				private function instantiateNewSpace():int		{			spaces.push( new Object() );						var idx:uint = spaces.length-1;						//Viewport3D(viewportWidth:Number = 640, viewportHeight:Number = 480, autoScaleToStage:Boolean = false, interactive:Boolean = false, autoClipping:Boolean = true, autoCulling:Boolean = true)			var viewport:Viewport3D = new Viewport3D( 640, 480, true, false, true, true);						viewport.name = currentSpace;						spaces[idx]["viewport"] = viewport;						var scene:Scene3D = new Scene3D();						spaces[idx]["scene"] = scene;						var camera:Camera3D = new Camera3D();			camera.x = 0;			camera.y = 0;			camera.z = 0;						var vp:Rectangle = new Rectangle();			vp.width = viewport.viewportWidth;			vp.height = viewport.viewportHeight;			camera.update(vp);						spaces[idx]["camera"] = camera;						var renderer:BasicRenderEngine = new BasicRenderEngine();						spaces[idx]["renderer"] = renderer;						spaces[idx]["name"] = currentSpace;						if ( stringToBoolean(settings.@statistics) || false )			{				var stats:StatsView = new StatsView( spaces[idx]["renderer"] );							spaces[idx]["stats"] = stats;							viewport.addChild(stats);			}						return idx;		}				public function getSpaceByName(name:String):Object		{			var i:int = 0;						while (i<spaces.length)			{				if (spaces[i]["name"] == name) 				{ 					return spaces[i]; 				}				i++			}			return null;		}				public function getDisplayObject3dByName(name:String):DisplayObject3D		{			for (var i:int = 0; i < spaces.length; i++)			{				var objs:Array = spaces[i]["scene"].objects as Array;				var num:int = objs.length;				for ( var j:int=0; j < num; j++ )				{					var obj:DisplayObject3D = DisplayObject3D(objs[ j ]);										if (obj.name == name) 					{						return obj;					}				}			}			return null;		}						///////////////////////////////////////////////////////////		// CAMERA CONTROLLER				private var startPoint:Point = new Point( 0,0 );				private var deltaPan:Number = 0;		private var deltaTilt:Number = 0;		public var sensitivity:Number = 60;		public var friction:Number = 0.3;		public var threshold:Number = 0.0001;		public var zoomIncrement:Number = 0.2;		public var keyIncrement:Number = 75;				private var autorotatorTimer:Timer;		private var _autorotatorDelay:Number = 15000;		private var _autorotatorOn:Boolean = true;				private var resting:Boolean = true;				private var mouseIsDown:Boolean = false;		private var keyIsDown:Boolean = false;				public var isAutorotating:Boolean = false;				private var up:Boolean = false;		private var down:Boolean = false;		private var left:Boolean = false;		private var right:Boolean = false;		private var zoomin:Boolean = false;		private var zoomout:Boolean = false;				private function initCameraController( autorotator:Boolean = true, autorotatorDelay:Number = 15000 ):void		{			//this._parent = _parent;			this.autorotatorDelay = autorotatorDelay			stage.addEventListener( MouseEvent.MOUSE_DOWN,mouseDownEvent, false, 100, true );			stage.addEventListener( MouseEvent.MOUSE_UP,mouseUpEvent, false, 0, true );			stage.addEventListener( Event.DEACTIVATE, mouseUpEvent, false, 0, true );			stage.addEventListener( KeyboardEvent.KEY_DOWN, keyDownEvent, false, 100, true );			stage.addEventListener( KeyboardEvent.KEY_UP, keyUpEvent, false, 0, true);						// start the autorotator			_autorotatorOn = autorotator;			if (autorotator)			{				setUpAutorotator();			}		}				protected function mouseDownEvent( event:MouseEvent ):void		{			if (event.target is ViewportBaseLayer)			{				mouseIsDown = true;								startPoint.x = stage.mouseX;				startPoint.y = stage.mouseY;								changeQuality("accelerating");								stopAutorotatorNow();			}		}				protected function keyDownEvent( event:KeyboardEvent ):void		{ 			switch( event.keyCode )			{			case Keyboard.UP:				up = true; 				startKeyMovement();			break;				case Keyboard.DOWN:				down = true;				startKeyMovement();			break;				case Keyboard.LEFT:				left = true;				startKeyMovement();			break;				case Keyboard.RIGHT:				right = true;				startKeyMovement();			break;			case Keyboard.SHIFT:				zoomin = true;				startKeyMovement();			break;			case Keyboard.CONTROL:				zoomout = true;				startKeyMovement();			break;			}		}				protected function startKeyMovement():void		{			stopAutorotatorNow();						keyIsDown = true;						changeQuality("accelerating");		}						protected function mouseUpEvent( event:Event ):void		{			mouseIsDown = false;						changeQuality("decelerating");		}				protected function keyUpEvent(event:KeyboardEvent):void		{			switch( event.keyCode )				{				case Keyboard.UP:					up = false;				break;					case Keyboard.DOWN:					down = false;				break;					case Keyboard.LEFT:					left = false;				break;					case Keyboard.RIGHT:					right = false;				break;				case Keyboard.SHIFT:					zoomin = false;				break;				case Keyboard.CONTROL:					zoomout = false;				break;				}			if ( !up && !down && !left && !right && !zoomin && !zoomout )			{				keyIsDown = false;								changeQuality("decelerating");			}		}				public function set autorotatorDelay(autorotatorDelay:Number):void		{			if (autorotatorTimer != null)			{				autorotatorTimer.delay = autorotatorDelay;			}			this._autorotatorDelay = autorotatorDelay;		}		public function get autorotatorDelay():Number		{			return _autorotatorDelay;		}				private function setUpAutorotator():void		{			autorotatorTimer = new Timer(autorotatorDelay);			autorotatorTimer.addEventListener("timer", startAutorotatorNow, false, 0, true);			restartAutorotatorTimer();		}				public function restartAutorotatorTimer():void		{			if (_autorotatorOn)			{				stopAutorotatorNow();				autorotatorTimer.start();			}		}				public function startAutorotatorNow(e:TimerEvent=null):void		{			if (autorotatorTimer)			{				autorotatorTimer.stop();				autorotatorTimer.reset();			}									isAutorotating = true;		}				public function stopAutorotatorNow():void		{			if (autorotatorTimer)			{				autorotatorTimer.stop();				autorotatorTimer.reset();			}						isAutorotating = false;		}				public function set autorotatorOn(value:Boolean):void		{			_autorotatorOn = value;			if (value)			{				restartAutorotatorTimer();			}			else			{				stopAutorotatorNow();			}		}				public function get autorotatorOn():Boolean		{			return _autorotatorOn;		}								/////////////////////////////////////////////////////																														//tools		private function pinToSphere(r:Number, p:Number, t:Number):Number3D		{			var pr:Number	= (-1*(p - 90)) * (Math.PI/180); 			var tr:Number	= t * (Math.PI/180);			var xc:Number = r * Math.cos(pr) * Math.cos(tr);			var yc:Number = r * Math.sin(tr);			var zc:Number = r * Math.sin(pr) * Math.cos(tr);						var n:Number3D = new Number3D();			n.x = xc;			n.y = yc;			n.z = zc;			return n;		}				// XML Tools		private function XMLCodeHook(name:String, checkCurrentSceneFirst:Boolean=true):void		{				var attr:String;						if (checkCurrentSceneFirst)			{				attr = findValueInXML(name, String, "");			}			else attr = settings.attribute(name).toString();						if ( attr != null && attr != "")			{				execute(attr);			}		}				public function execute(attr:String):void		{						if ( attr != null && attr != "")			{				trace("PS: execute: "+attr);								var lines:Array = attr.split(";");				for (var i:uint = 0; i < lines.length; i++)				{						if ( lines[i].indexOf(":") != -1 )					{						var action:Array = lines[i].split(":");						var func:String = action[0];						var argStr:String = action[1];						var args:Array = argStr.split(",");							root[func].apply(root, args);					}					else 					{						root[lines[i]].call(root);					}				}			}		}				//search in child node first, then in settings node				private function findSpaceNode(name:String):XML		{			var spaceNode:XML;			for each (spaceNode in settings.spaces.children())			{				if (spaceNode.@id == name)				{					break;				}			}			if (spaceNode.@id == name)				return spaceNode;			else return null;		}				private function findValueInXML(name:String, ReturnClass:Class, def:*):*		{			// check the currentSpace node for the value first			var cs:XML = findSpaceNode(currentSpace);			if (cs)			{				if ( cs.attribute(name).toString().length != 0 )				{					if ( ! ReturnClass is Boolean)					{ 						return ReturnClass( cs.attribute(name) );					}					else					{ 						return ReturnClass( stringToBoolean(cs.attribute(name)) );					}				}			}			// check the spaces node next			if ( settings.spaces.attribute(name).toString().length != 0 )			{ 				if ( ! ReturnClass is Boolean)				{					return ReturnClass( settings.spaces.attribute(name) );				}				else				{					return ReturnClass( stringToBoolean(settings.spaces.attribute(name)) );				}			}			else return ReturnClass(def);		}				private function stringToBoolean(str:String):Boolean		{			var ret:Boolean;			ret = (str == "true") ? true : false;			return ret;		}					}}