package {	import flash.net.URLLoader;	import flash.net.URLRequest;	import flash.net.URLLoaderDataFormat;		import flash.system.ApplicationDomain;		import br.com.stimuli.loading.BulkLoader;	import br.com.stimuli.loading.BulkProgressEvent;	import br.com.stimuli.loading.BulkErrorEvent;		import flash.utils.Dictionary;		import flash.display.*;	import flash.text.TextField;	import flash.text.TextFieldAutoSize;	import flash.text.TextFormat;	import flash.display.StageAlign;	import flash.display.StageScaleMode;	import flash.geom.Rectangle;	import flash.events.TimerEvent;	import flash.utils.Timer;	import flash.geom.Point;		import flash.events.KeyboardEvent;	import flash.ui.Keyboard;		import flash.display.Sprite;	import flash.events.Event;	import flash.events.ProgressEvent;	import flash.events.MouseEvent;		import org.papervision3d.cameras.Camera3D;	import zephyr.objects.primitives.Cube;	import zephyr.objects.primitives.Cylinder;	import org.papervision3d.objects.primitives.Plane;	import zephyr.objects.primitives.Sphere;	import org.papervision3d.render.BasicRenderEngine;	import org.papervision3d.scenes.Scene3D;	import org.papervision3d.view.Viewport3D;	import org.papervision3d.events.InteractiveScene3DEvent;	import org.papervision3d.objects.DisplayObject3D;	import org.papervision3d.materials.BitmapMaterial;	import org.papervision3d.materials.utils.MaterialsList;	import org.papervision3d.core.proto.MaterialObject3D;	import org.papervision3d.events.RendererEvent;	import org.papervision3d.core.render.data.RenderStatistics;	import org.papervision3d.core.math.Number3D;	import org.papervision3d.view.layer.ViewportBaseLayer;	import org.papervision3d.view.layer.ViewportLayer;	import org.papervision3d.materials.MovieMaterial;	import org.papervision3d.materials.VideoStreamMaterial;		import flash.media.Video;	import flash.net.NetStream;	import flash.net.NetConnection;	import flash.system.Security;		//import gs.TweenFilterLite;	import gs.TweenLite;	import flash.utils.getDefinitionByName;	import gs.easing.*;		import com.adobe.utils.StringUtil;		import zephyr.objects.StageAlignedSprite;	import zephyr.objects.Hotspot;	import zephyr.objects.primitives.GeodesicSphere;		import org.papervision3d.view.stats.StatsView;	public class PanoSalado extends Sprite	{				public var bulkLoader : BulkLoader;						public var ui:Sprite = new Sprite();				public var spaces:Array = new Array();				public var viewports:Sprite = new Sprite();				//public var cameraController:CameraController;				public var currentSpace:String = "";				public var lastSpace:String = "";				public var loadingSpace:String = "";				private var interactionEquivalents:Object = { mouseClick:"onClick", mouseOver:"onOver", mouseOut:"onOut", mousePress:"onPress", mouseRelease:"onRelease", mouseMove:"onMouseMove", mouseDown:"onPress", mouseUp:"onRelease", click:"onClick" };				private var unclaimedMaterials:Dictionary = new Dictionary(true);				private var _worldDirty:Boolean = false;				public var settings : XML;		//		public var loadMeter:Sprite = new Sprite();				public var resizeDict:Object = new Object();				private var moduleLoader:Object;				private var ModuleLoader:Class;				private var BroadcastEvent:Class;				private var CustomActions:Class;				private var qtvrCount:int = 0;				public function PanoSalado() 		{			addEventListener(Event.ADDED_TO_STAGE, stageReady, false, 0, true);						//add viewports sprite to display list.  It will hold all the viewports so they can be iterated/isolated from other items			addChild(viewports);						addEventListener(Event.ENTER_FRAME, doRender, false, 0, true);						//set up bulk loader			bulkLoader = new BulkLoader("bulkLoader");			//			bulkLoader.addEventListener(BulkProgressEvent.PROGRESS, onAllProgress, false, 0, true);			bulkLoader.addEventListener(BulkLoader.COMPLETE, onAllLoaded, false, 99, true);						addChild(ui);			ui.addEventListener(MouseEvent.CLICK, mouseEventHandler, false, 0, true);			ui.addEventListener(MouseEvent.MOUSE_OVER, mouseEventHandler, false, 0, true);			ui.addEventListener(MouseEvent.MOUSE_OUT, mouseEventHandler, false, 0, true);			ui.addEventListener(MouseEvent.MOUSE_DOWN, mouseEventHandler, false, 0, true); 			ui.addEventListener(MouseEvent.MOUSE_UP, mouseEventHandler, false, 0, true); 			ui.addEventListener(MouseEvent.MOUSE_MOVE, mouseEventHandler, false, 0, true); 		}				public function stageReady(e:Event):void		{			ModuleLoader = ApplicationDomain.currentDomain.getDefinition("ModuleLoader") as Class;						BroadcastEvent = ApplicationDomain.currentDomain.getDefinition("zephyr.BroadcastEvent") as Class;						moduleLoader = ModuleLoader( parent );						moduleLoader.addEventListener(BroadcastEvent.ALL_LAYERS_LOADED, allLayersLoaded, false, 0, true);						//stage.align = StageAlign.TOP_LEFT;			//stage.scaleMode = StageScaleMode.NO_SCALE;			stage.frameRate = 60;			stage.quality = StageQuality.HIGH;						stage.addEventListener(Event.RESIZE, onResize, false, 100, true);						if ( ! moduleLoader.xmlByName["PanoSalado"] )			{				var xmlLoader:URLLoader = new URLLoader();				xmlLoader.dataFormat = URLLoaderDataFormat.BINARY;				xmlLoader.load( new URLRequest( loaderInfo.parameters.xml?loaderInfo.parameters.xml:"PanoSalado.xml" ) );				xmlLoader.addEventListener(Event.COMPLETE, onXMLLoaded, false, 0, true);			}			else			{				settings = moduleLoader.xmlByName["PanoSalado"];				onXMLLoaded();			}						//loadMeter.graphics.beginFill(0xFFFFFF);			//loadMeter.graphics.drawRect(0,0,stage.stageWidth,3);			//loadMeter.graphics.endFill();			//loadMeter.scaleX = 0;			//addChild(loadMeter);		}				private function allLayersLoaded(e:*):void		{			e = e as BroadcastEvent;						if ( ApplicationDomain.currentDomain.hasDefinition("CustomActions") )				CustomActions = ApplicationDomain.currentDomain.getDefinition("CustomActions") as Class;		}				private function onXMLLoaded(e:Event=null):void		{			if (e)				settings = XML(e.target.data);						if (settings.@stageQuality.length != 0)			{				switch(settings.@stageQuality) 				{					case "low":						stage.quality = StageQuality.LOW;    						break;					case "medium":						stage.quality = StageQuality.MEDIUM;    						break;					case "high":					default:						stage.quality = StageQuality.HIGH;    						break;					case "best":						stage.quality = StageQuality.BEST;    						break;				}			}						initCameraController( stringToBoolean(settings.spaces.@autorotator || "true" ), int(settings.spaces.@autorotatorDelay) || 15000 );						refresh();						//onStart code hook, pass second arg false to NOT check for onStart in non-existent current scene node.			XMLCodeHook("onStart", false);					}				private function refresh():void		{			sensitivity = 	findValueInXML("cameraSensitivity", Number, 	60);			friction = 		findValueInXML("cameraFriction", Number, 0.3);			threshold = 	findValueInXML("cameraRestThreshold", Number, 0.0001);			keyIncrement = 	findValueInXML("cameraKeyIncrement", Number, 75);			zoomIncrement = findValueInXML("cameraZoomIncrement", Number, 0.2);						maxTilt = findValueInXML("cameraMaximumTilt", Number, 9999);			minTilt = findValueInXML("cameraMinimumTilt", Number, 9999);						maxPan = findValueInXML("cameraMaximumPan", Number, 9999);			minPan = findValueInXML("cameraMinimumPan", Number, 9999);						minZoom = findValueInXML("cameraMinimumZoom", Number, 1);			maxZoom = findValueInXML("cameraMaximumZoom", Number, 50);						dqa = findValueInXML("dynamicQualityAdjustment", Boolean, true) ;						accSmooth =  findValueInXML("smoothOnAcceleration", Boolean, false );			accPrecise =  findValueInXML("preciseOnAcceleration", Boolean, true );			accPrecision = findValueInXML("precisionOnAcceleration", int, 32);						decSmooth =  findValueInXML("smoothOnDeceleration", Boolean, true );			decPrecise =  findValueInXML("preciseOnDeceleration", Boolean, true );			decPrecision = findValueInXML("precisionOnDeceleration", int, 8);						stopSmooth =  findValueInXML("smoothAtRest", Boolean, true) ;			stopPrecise =  findValueInXML("preciseAtRest", Boolean, true );			stopPrecision = findValueInXML("precisionAtRest", int, 1);						aah = findValueInXML("autorotatorAutoHorizon", Boolean, true);			da = findValueInXML("autorotatorIncrement", Number, 0.25);		}				private function onSingleItemLoaded(e:Event):void		{						var bm:BitmapMaterial = new BitmapMaterial( BitmapData(e.target._content.bitmapData) );			unclaimedMaterials[ e.target.url.url.toString() ] = bm ;		}				private function qtvrXMLLoaded(e:Event):void		{			qtvrCount -= 1;			for each (var mov:XML in findXMLNode(loadingSpace)..mov)			{				var id:String = e.target.url.url.toString();				if (mov == id )				{					var target:XML = mov.parent(); 										var xml:XML = bulkLoader.getXML(id);										if( stringToBoolean(target.@applyCameraSettingsFromThisQTVR) )					{						target.parent().@cameraMinimumPan = xml.@cameraMinimumPan;						target.parent().@cameraMaximumPan = xml.@cameraMaximumPan;						target.parent().@cameraMinimumTilt = xml.@cameraMinimumTilt;						target.parent().@cameraMaximumTilt = xml.@cameraMaximumTilt;						target.parent().@cameraMinimumZoom = xml.@cameraMinimumZoom;						target.parent().@cameraMaximumZoom = xml.@cameraMaximumZoom;						target.parent().@cameraPan = xml.@cameraPan;						target.parent().@cameraTilt = xml.@cameraTilt;						target.parent().@cameraZoom = xml.@cameraZoom;					}										target.setChildren( xml.children() );										for each (var tile:XML in target.tile)					{ 						bulkLoader.add(tile.toString(), { type:"image", weight: (tile.@weight || 10) });					}										bulkLoader.start();				}			}		}		// 		private function onAllProgress(e : BulkProgressEvent) : void// 		{// 		 	//trace("progress event: loaded" , e.bytesLoaded," of ",  e.bytesTotal);// 		 	loadMeter.scaleX = e.weightPercent;// 		}				private function onAllLoaded(e : BulkProgressEvent=null) : void		{			if ( qtvrCount != 0 ) 				return;						trace("PS: initializing " + currentSpace );						lastSpace = currentSpace;						currentSpace = loadingSpace;						loadingSpace = "";						refresh();						// create a new space (viewport, scene, and camera)			var idx:int = instantiateNewSpace();						var thisSpace:Object = spaces[idx];						//set up viewport			setupViewport( thisSpace.viewport );						//set-up camera			setupCamera(thisSpace.camera, spaces[idx-1]);						//iterate through all the objects in the scene (pano, hotspots, etc)			for each (var xml:XML in findXMLNode(currentSpace).children() )			{				var nodeName:String = xml.name().localName.toString();								//create papervision primitive by calling the function bearing its name (cube, plane, sphere, etc)				var primitive:Object = this[ nodeName ].call(null, xml);								if ( nodeName != "stageAlignedSprite" )				{					primitive.name = xml.@id.toString();										//set position and rotation of primitive, using += so that it can be pre adjusted e.g. sphere					primitive.x += int(xml.@x) || 0;					primitive.y += int(xml.@y) || 0;					primitive.z += int(xml.@z) || 0;										primitive.rotationX += Number(xml.@rotationX) || 0;					primitive.rotationY += Number(xml.@rotationY) || 0; 					primitive.rotationZ += Number(xml.@rotationZ) || 0; 										primitive.visible = stringToBoolean(xml.@visible || "true");					primitive.useOwnContainer = stringToBoolean(xml.@useOwnContainer || "false");										if ( primitive.useOwnContainer )					{						primitive.alpha = Number(xml.@alpha) || 1 ;						primitive.blendMode = xml.@blendMode.toString() || "normal";						//primitive.filters = ;					}										if ( xml.@onClick.toString() != "" ) { primitive.addEventListener(InteractiveScene3DEvent.OBJECT_CLICK, interactionScene3DEventHandler, false, 0, true); }					if ( xml.@onOver.toString() != "" ) { primitive.addEventListener(InteractiveScene3DEvent.OBJECT_OVER, interactionScene3DEventHandler, false, 0, true); }					if ( xml.@onOut.toString() != "" ) { primitive.addEventListener(InteractiveScene3DEvent.OBJECT_OUT, interactionScene3DEventHandler, false, 0, true); }					if ( xml.@onPress.toString() != "" ) { primitive.addEventListener(InteractiveScene3DEvent.OBJECT_PRESS, interactionScene3DEventHandler, false, 0, true); }					if ( xml.@onRelease.toString() != "" ) { primitive.addEventListener(InteractiveScene3DEvent.OBJECT_RELEASE, interactionScene3DEventHandler, false, 0, true); }					if ( xml.@onOverMove.toString() != "" ) { primitive.addEventListener(InteractiveScene3DEvent.OBJECT_MOVE, interactionScene3DEventHandler, false, 0, true); }										if (stringToBoolean( xml.@useHandCursor || "false") )					{						primitive.addEventListener(InteractiveScene3DEvent.OBJECT_OVER, cursorHandler, false, 0, true);						primitive.addEventListener(InteractiveScene3DEvent.OBJECT_OUT, cursorHandler, false, 0, true);					}										if ( xml.@tooltip.toString() != "" )					{						primitive.addEventListener(InteractiveScene3DEvent.OBJECT_OVER, tooltipHandler, false, 0, true);						primitive.addEventListener(InteractiveScene3DEvent.OBJECT_OUT, tooltipHandler, false, 0, true);					}										primitive.updateTransform();										thisSpace["scene"].addChild( primitive, xml.@id.toString() );				}				else 				{					ui.addChild( StageAlignedSprite(primitive) );				}			}						//onResize();						bulkLoader.removeAll();												// add viewport to the displaylist			viewports.addChild( thisSpace["viewport"] );									//transitionStart code hook			XMLCodeHook("onTransitionStart");						var trans:String = findValueInXML("transition", String, "tween:currentSpace.viewport.alpha from 0 over 1.5 seconds using Expo.easeIn");						var idxThenDo:int = trans.indexOf("then do ");						if ( idxThenDo == -1 )			{				if ( trans.lastIndexOf(";")+1 == trans.length)					trans = trans.substr(0, trans.length-1) + " then do onTransitionEnd";				else					trans = trans + " then do onTransitionEnd";			}			else			{				if ( trans.lastIndexOf(";")+1 == trans.length)					trans = trans + " onTransitionEnd";				else					trans = trans + "; onTransitionEnd";			}			execute( trans );						_worldDirty = true;									//code hook			XMLCodeHook("onDisplay");						//remove onDisplay so it doesn't trigger again			settings.@onDisplay = "";					}				private function setupViewport(viewport:Viewport3D):void		{			viewport.interactive = findValueInXML("interactive", Boolean, true);			viewport.autoScaleToStage = findValueInXML("viewportAutoScaleToStage", Boolean, true );			viewport.autoCulling = findValueInXML("viewportAutoCulling", Boolean, true );			viewport.autoClipping = findValueInXML("viewportAutoClipping", Boolean, true );			viewport.viewportWidth = findValueInXML("viewportWidth", Number, 640 );			viewport.viewportHeight = findValueInXML("viewportHeight", Number, 480 );			viewport.x = findValueInXML("viewportX", Number, 0 );			viewport.y = findValueInXML("viewportY", Number, 0 );		}				private function setupCamera(camera:Camera3D, lastSpace:Object=null):void		{			// set up camera: 			var cameraContinuity:Boolean = findValueInXML("cameraRetainsLastValues", Boolean, false);			var pan:Number = findValueInXML("cameraPan", Number, 0 );			var tilt:Number = findValueInXML("cameraTilt", Number, 0);			var zoom:Number = findValueInXML("cameraZoom", Number, 12); 			var focus:Number = findValueInXML("cameraFocus", Number, 100);			var camX:Number = findValueInXML("cameraX", Number, 0);			var camY:Number = findValueInXML("cameraY", Number, 0);			var camZ:Number = findValueInXML("cameraZ", Number, 0);						// leash free or default unspecified leashing			if (!cameraContinuity)			{				camera.rotationX = tilt;				camera.rotationY = pan;				camera.rotationZ = 0;				camera.zoom = zoom;				camera.focus = focus;				camera.x = camX;				camera.y = camY;				camera.z = camZ;				}			else			{				//leash = lock				camera.rotationX = lastSpace != null ? lastSpace["camera"].rotationX : tilt ;				camera.rotationY = lastSpace != null ? lastSpace["camera"].rotationY : pan ;				camera.rotationZ = lastSpace != null ? lastSpace["camera"].rotationZ : 0 ;				camera.zoom = lastSpace != null ? lastSpace["camera"].zoom : zoom ;				camera.focus = lastSpace != null ? lastSpace["camera"].focus : focus ;				camera.x = lastSpace != null ? lastSpace["camera"].x : camX ;				camera.y = lastSpace != null ? lastSpace["camera"].y : camY ;				camera.z = lastSpace != null ? lastSpace["camera"].z : camZ ;			}		}				private function createMaterial(xml:XML):*		{			var returnObject:*;			var materials:MaterialsList = new MaterialsList();						if (xml.file != undefined)			{ // BitmapMaterial				var numFileMaterials:int = xml.file.length();								for each (var file:XML in xml.file)				{					var material:BitmapMaterial =  BitmapMaterial(unclaimedMaterials[file.toString()]);										applyPropertiesToMaterial(material, xml);										if ( numFileMaterials > 1 )					{						materials.addMaterial( material, file.@face.toString() );					}				}								if ( numFileMaterials > 1 )					returnObject = materials;				else					returnObject = material;			}			if (xml.stream != undefined)			{ // VideoStreamMaterial				var numStreamMaterials:int = xml.stream.length();								for each (var stream:XML in xml.stream)				{					//VideoStreamMaterial ( video:Video, stream:NetStream , precise:Boolean = false )					Security.loadPolicyFile( xml.stream.@policyFile.toString() );										var vid:Video = new Video(width, height);										var nc:NetConnection = new NetConnection();										nc.connect(null);										var ns:NetStream = new NetStream(nc);										ns.client = new Object();										ns.checkPolicyFile = true;										ns.play( stream.toString() );										vid.attachNetStream ( ns );										material = new VideoStreamMaterial( vid, ns , false );										applyPropertiesToMaterial(material, xml);										if ( numStreamMaterials > 1 )						materials.addMaterial( material, stream.@face.toString() );				}								if ( numStreamMaterials > 1 )					returnObject = materials;				else					returnObject = material;			}						return returnObject;		}				private function applyPropertiesToMaterial(material:BitmapMaterial, xml:XML):BitmapMaterial		{			if ( findValueInXML("dynamicQualityAdjustment", Boolean, true) )			{				material.smooth =  findValueInXML("smoothAtRest", Boolean, true  ) ;								material.precise =  findValueInXML("preciseAtRest", Boolean, true  ) ;							material.precision = findValueInXML("precisionAtRest", int, 1) ;			}			else			{				material.smooth = stringToBoolean( xml.@smooth || "false") ;									material.precise = stringToBoolean( xml.@precise || "false") ;								material.precision = int( xml.@precision) || 8 ;			}						material.oneSide = stringToBoolean( xml.@oneSide || "true") ;					material.interactive = stringToBoolean( xml.@interactive || "false") ;						return material;		}				private function sphere(xml:XML):Object		{						var material:BitmapMaterial = createMaterial(xml) as BitmapMaterial;			//var material:BitmapMaterial =  BitmapMaterial(unclaimedMaterials[xml.file.toString()]);						var segments:int = int( xml.@segments) || 9 ;						var radius:int = int( xml.@radius ) || 50000;						var reverse:Boolean = stringToBoolean(xml.@reverse || "true");						var sphere:Sphere = new Sphere(material, radius, segments, segments, reverse );									sphere.rotationY = -50;			sphere.rotationZ = 0;									return sphere;		}				private function geodesicSphere(xml:XML):Object		{						var material:BitmapMaterial = createMaterial(xml) as BitmapMaterial;						//var material:BitmapMaterial =  BitmapMaterial(unclaimedMaterials[xml.file.toString()]);						var segments:int = int( xml.@segments) || 9 ;						var radius:int = int( xml.@radius ) || 50000;						var reverse:Boolean = stringToBoolean(xml.@reverse || "true");						//GeodesicSphere( material:MaterialObject3D=null, radius:Number=100, fractures:int=2, initObject:Object=null ) 			var geoSphere:GeodesicSphere = new GeodesicSphere(material, radius, segments, true );									geoSphere.rotationY = 90;									return geoSphere;		}				private function cylinder(xml:XML):Cylinder		{			//Cylinder( material:MaterialObject3D=null, radius:Number=100, height:Number=100, segmentsW:int=8, segmentsH:int=6, topRadius:Number=-1, topFace:Boolean=true, bottomFace:Boolean=true )						var bmd:BitmapData = bulkLoader.getBitmapData(xml.file.toString(), false);						/// THIS MAY NEED ADJUSTING			var height:Number = (bmd.height/bmd.width)*50000*2*Math.PI;						var material:BitmapMaterial = createMaterial(xml) as BitmapMaterial;						var segments:int = int( xml.@segments) || 15 ;						var radius:int = int( xml.@radius ) || 50000;						var reverse:Boolean = stringToBoolean(xml.@reverse || "true");						var cyl:Cylinder = new Cylinder(material, radius, height, segments, segments, -1, false, false, reverse );			//var cyl:Cylinder = new Cylinder(material, radius, height, segments, segments, -1, false, false, reverse );						/// THIS MAY NEED ADJUSTING 			cyl.rotationY = -50; 			cyl.rotationZ = 0; 			 			if ( stringToBoolean(xml.@autoFOV) ) 			{ 				var mt:Number = Math.atan( (height*0.5)/50000) * 180/Math.PI; 				minTilt = -mt; 				maxTilt = mt; 			}						return cyl;		}				private function cube(xml:XML):Cube		{			var materials:MaterialsList = createMaterial(xml) as MaterialsList;						var insideFaces  : int; 			if ( ! stringToBoolean(xml.@reverse) )				insideFaces	 = Cube.ALL;			else 				insideFaces	 = Cube.NONE;							var excludeFaces :int = Cube.NONE;						var segments:int = int( xml.@segments) || 9 ;						var width:int = int( xml.@width ) || 100000 ;						var normalCube:Cube = new Cube( materials, width, width, width, segments, segments, segments, insideFaces, excludeFaces );						return normalCube;		}				private function hotspot(xml:XML):Hotspot		{			var bmd:BitmapData = bulkLoader.getBitmapData(xml.file.toString(), false);						var width:Number = (2 / bmd.width ) * 40000;						var height:Number = (2 / bmd.height ) * 40000;						var material:BitmapMaterial = createMaterial(xml) as BitmapMaterial;						material.interactive = stringToBoolean( xml.@interactive) || true ;						var segments:int = int( xml.@segments) || 3 ;						var pan:Number = Number( xml.@pan) || 0 ;						var tilt:Number = Number( xml.@tilt) || 0 ; 						var hs:Hotspot = new Hotspot(pan, tilt, material, width, height, segments, segments );						return hs;		}				private function plane(xml:XML):Plane		{			var width:Number = int( xml.@width) || 100 ;						var height:Number = int( xml.@height) || 100 ;						var material:MaterialObject3D = createMaterial(xml) as MaterialObject3D;						var segments:int = int( xml.@segments) || 3 ;						var plane:Plane = new Plane( material, width, height, segments, segments );						return plane;		}				private function qtvr(xml:XML):Cube		{			var q:Cube = tiledCube(xml);						return q;		}				private function tiledCube(xml:XML):Cube		{			var bitmapDatasCreated:Boolean = false;						var bmd:BitmapData;						for each (var singleTile:XML in xml.tile)			{				bmd = bulkLoader.getBitmapData(singleTile.toString(), true) as BitmapData;								var w:Number = bmd.width;				var h:Number = bmd.height;								if ( ! bitmapDatasCreated)				{					var wTotal:Number = bmd.width * Math.sqrt( int( xml.tile.(@face == "front").length() ) )					var hTotal:Number = bmd.height * Math.sqrt( int( xml.tile.(@face == "front").length() ) )										var ft:BitmapData = new BitmapData(wTotal, hTotal, false, 0xFF0000);					var lt:BitmapData = new BitmapData(wTotal, hTotal, false, 0x00FF00);					var rt:BitmapData = new BitmapData(wTotal, hTotal, false, 0x0000FF);					var bk:BitmapData = new BitmapData(wTotal, hTotal, false, 0x888888);					var up:BitmapData = new BitmapData(wTotal, hTotal, false, 0xFFFFFF);					var dn:BitmapData = new BitmapData(wTotal, hTotal, false, 0x000000);										bitmapDatasCreated = true;				}								var rect:Rectangle = new Rectangle(0,0,w,h);				var pt:Point = new Point(w * int(singleTile.@x_offset), h * int(singleTile.@y_offset));								switch( singleTile.@face.toString() )				{					case "front":						ft.copyPixels(bmd,rect,pt);						break;					case "left":						lt.copyPixels(bmd,rect,pt);						break;					case "right":						rt.copyPixels(bmd,rect,pt);						break;					case "back":						bk.copyPixels(bmd,rect,pt);						break;					case "up":						up.copyPixels(bmd,rect,pt);						break;					case "down":						dn.copyPixels(bmd,rect,pt);						break;					default:						trace("invalid face value in " + xml.@id+ ", tile: "+ singleTile );				}			}						bmd.dispose();						var matsArray:Array = new Array();			matsArray.push( { id:"front", material:new BitmapMaterial(ft) } );			matsArray.push( { id:"left", material:new BitmapMaterial(lt) } );			matsArray.push( { id:"right", material:new BitmapMaterial(rt) } );			matsArray.push( { id:"back", material:new BitmapMaterial(bk) } );			matsArray.push( { id:"top", material:new BitmapMaterial(up) } );			matsArray.push( { id:"bottom", material:new BitmapMaterial(dn) } );						var materials:MaterialsList = new MaterialsList();						for each (var o:Object in matsArray)			{				if ( findValueInXML("dynamicQualityAdjustment", Boolean, true) )				{					o.material.smooth =  findValueInXML("smoothAtRest", Boolean, true  ) ;										o.material.precise =  findValueInXML("preciseAtRest", Boolean, true  ) ;									o.material.precision = findValueInXML("precisionAtRest", int, 1) ;				}				else				{					o.material.smooth = stringToBoolean( xml.@smooth || "false") ;											o.material.precise = stringToBoolean( xml.@precise || "false") ;										o.material.precision = int( xml.@precision) || 8 ;				}								o.material.oneSide = stringToBoolean( xml.@oneSide || "true") ;							o.material.interactive = stringToBoolean( xml.@interactive || "false") ;								materials.addMaterial( o.material, o.id );			}						var insideFaces  : int; 			if ( ! stringToBoolean(xml.@reverse) )				insideFaces	 = Cube.ALL;			else 				insideFaces	 = Cube.NONE;						var excludeFaces :int = Cube.NONE;						var segments:int = int( xml.@segments) || 9 ;						var width:int = int( xml.@width ) || 100000 ;						var cube:Cube = new Cube( materials, width, width, width, segments, segments, segments, insideFaces, excludeFaces );						return cube;		}				// 		private function stageAlignedSprite(xml:XML):StageAlignedSprite// 		{// 			var bm:BitmapData = bulkLoader.getBitmapData(xml.file.toString(), true);// 			// 			var sp:StageAlignedSprite = new StageAlignedSprite();// 			// 			sp.graphics.beginBitmapFill(bm, null, false, false);// 			// 			sp.graphics.drawRect(0,0,bm.width,bm.height);// 			// 			sp.graphics.endFill();// 			// 			sp.scaleX = Number(xml.@scaleX) || 1;// 			// 			sp.scaleY = Number(xml.@scaleY) || 1;// 			// 			sp.rotation = Number(xml.@rotation) || 0;// 			// 			sp.alpha = Number(xml.@alpha) || 1;// 			// 			sp.visible = stringToBoolean(xml.@visible || "true");// 			// 			sp.cacheAsBitmap = stringToBoolean(xml.@cacheAsBitmap || "false");// 			// 			sp.blendMode = String(xml.@blendMode) || "normal";// 			// 			sp.name = String(xml.@id) || "";// 			// 			sp.alignment = String(xml.@align) || "tl";// 			// 			sp.offsetX = Number(xml.@offsetX) || 0;// 			// 			sp.offsetY = Number(xml.@offsetY) || 0;// 			//sp.align();// 			return sp;// 		}								protected var dqa:Boolean,		accSmooth:Boolean,		accPrecise:Boolean,		accPrecision:int,		decSmooth:Boolean,		decPrecise:Boolean,		decPrecision:int,		stopSmooth:Boolean,		stopPrecise:Boolean,		stopPrecision:int;				private function changeQuality(type:String):void		{ 		/* change precise, smooth, and precision while moving camera for better fps		loops through all the scenes in all the spaces, getting all the objects from each, 		and then pushing either the materials from the materialsList, or the material into		an array, and then applies the changes to each item in the array.		*/			if ( dqa )			{				var allmats:Array = getAllMaterials();								var bmToChange:BitmapMaterial,				matToChange:MaterialObject3D;								while ( matToChange = allmats.pop() )				{					bmToChange = BitmapMaterial(matToChange);					if (type == "accelerating")					{						bmToChange.smooth = accSmooth;						bmToChange.precise = accPrecise;						bmToChange.precision = accPrecision;					}					else if (type == "decelerating")					{						bmToChange.smooth = decSmooth;						bmToChange.precise = decPrecise;						bmToChange.precision = decPrecision;					}					else if (type == "resting")					{						bmToChange.smooth = stopSmooth;						bmToChange.precise = stopPrecise;						bmToChange.precision = stopPrecision;					}				}			}						//_worldDirty is set when camera or objects in scene have changed and need rendering.			_worldDirty = true;		}				private function getAllMaterials():Array		{			var matsToChange:Array = new Array(),			matToChange:MaterialObject3D,			objsToChange:Array,			numObjsToChange:int,			objToChange:DisplayObject3D;						for (var i:int = 0; i < spaces.length; i++)			{				objsToChange = spaces[i]["scene"].objects as Array;				numObjsToChange = objsToChange.length;				for ( var j:int=0; j < numObjsToChange; j++ )				{					objToChange = DisplayObject3D(objsToChange[ j ]);										if (objToChange.materials)					{/// obj.materials is the materialsList, if it is not null add them						for each(  matToChange in objToChange.materials.materialsByName )						{							matsToChange.push(matToChange);						}					}					else 					{// obj.material is the material, add it						matsToChange.push( objToChange.material );					}				}			}			return matsToChange;		}				protected var dp:Number,		dt:Number,		maxTilt:Number,		minTilt:Number,		maxPan:Number,		minPan:Number,		cam:Camera3D,		newTilt:Number,		newPan:Number,		maxZoom:Number,		minZoom:Number;				private function moveCamera(dp:Number, dt:Number, dz:Number):void		{			dt *= -1;						for (var i:int=0; i < spaces.length; i++)			{				var cam:Camera3D = Camera3D(spaces[i]["camera"]);								if (maxTilt == 9999)					maxTilt = 90 + cam.vfov*0.5;				if (minTilt == 9999)					minTilt = -90 - cam.vfov*0.5;								if (dt >= 0)				{					newTilt = cam.rotationX + dt + cam.vfov*0.5;					if (newTilt <= maxTilt)						cam.rotationX += dt;				}				else				{					newTilt = cam.rotationX + dt - cam.vfov*0.5;					if (newTilt >= minTilt)						cam.rotationX += dt;				}								if (dp >= 0)				{					if (maxPan == 9999)						{ cam.rotationY += dp; }					else 					{						newPan = cam.rotationY + dp + cam.hfov*0.5;						if (newPan <= maxPan)							cam.rotationY += dp;					}				}				else				{					if (minPan == 9999)						{ cam.rotationY += dp; }					else 					{						newPan = cam.rotationY + dp - cam.hfov*0.5;						if (newPan >= minPan)							cam.rotationY += dp;					}				}								//zoom 				cam.zoom += dz;				if (cam.zoom < minZoom) { cam.zoom = minZoom }				if (cam.zoom > maxZoom) { cam.zoom = maxZoom }			}						//_worldDirty is set when camera or objects in scene have changed and need rendering.			_worldDirty = true;		}				protected var da:Number; // deltaAutorotate		protected var aah:Boolean;		private function autorotate():void		{			//da = findValueInXML("autorotatorIncrement", Number, 0.25);			for (var i:int=0; i < spaces.length; i++)			{				var cam:Camera3D = Camera3D(spaces[i].camera);				if (aah)				{					if (da > 0)					{						if (cam.rotationX > da ) { cam.rotationX -= da; }						else if (cam.rotationX < -da ) { cam.rotationX += da; }					}					else					{						if (cam.rotationX < da ) { cam.rotationX -= da; }						else if (cam.rotationX > -da ) { cam.rotationX += da; }					}				}				cam.rotationY += da;			}			_worldDirty = true;		}				private function onResize(e:Event):void		{			_worldDirty = true;		}				private function doRender(e:Event=null):void		{			/* Check if any of the camera control flags are set and if so move the camera			*/						if (mouseIsDown || keyIsDown)			{				if (keyIsDown)				{					if ( up ) { startPoint.x = stage.mouseX, startPoint.y = stage.mouseY + keyIncrement ; }					if ( down ) { startPoint.x = stage.mouseX, startPoint.y = stage.mouseY - keyIncrement ; }					if ( left) { startPoint.x = stage.mouseX + keyIncrement, startPoint.y = stage.mouseY ; }					if ( right ) { startPoint.x = stage.mouseX - keyIncrement, startPoint.y = stage.mouseY ; }					if ( zoomin ) 					{ 						moveCamera(0, 0, zoomIncrement);												resting = false;					}					if ( zoomout ) 					{ 						moveCamera(0, 0, -zoomIncrement);												resting = false;					}				}				if (mouseIsDown || up || down || left || right)				{					// calculate new position changes					deltaPan = (deltaPan - (((startPoint.x - stage.mouseX) * sensitivity) * 0.00006));					deltaTilt = (deltaTilt + (((startPoint.y - stage.mouseY) * sensitivity) * 0.00006));				}			}			// motion is still over the threshold, so apply friction			if ( ( (deltaPan * deltaPan) + (deltaTilt * deltaTilt) ) > threshold ) 			{				// always apply friction so that motion slows AFTER mouse is up				deltaPan = (deltaPan * (1 - friction) );				deltaTilt = (deltaTilt * (1 - friction) );								moveCamera( deltaPan, deltaTilt, 0);								resting = false;			} 			else 			{ // motion is under threshold stop camera motion				if ( !mouseIsDown && !keyIsDown && !resting)				{						// motion is under threshold, stop and remove enter frame listener					deltaPan = 0;					deltaTilt = 0;										moveCamera(deltaPan, deltaTilt, 0)										changeQuality("resting");										if (_autorotatorOn)						restartAutorotatorTimer();											resting = true;								}			}			if (isAutorotating) autorotate();						var i:int;						// check if anything has set the _worldDirty flag and if so render			if ( _worldDirty )			{				for (i = 0; i < spaces.length; i++)				{					BasicRenderEngine(spaces[i].renderer).renderScene					( 					Scene3D(spaces[i].scene), 					Camera3D(spaces[i].camera), 					Viewport3D(spaces[i].viewport) 					);				}								_worldDirty = false;			}			else			{ // check if there are any animated materials that need continuous rendering.								var animatedLayer:ViewportLayer;				var animatedLayerCreated:Boolean = false;								for (i = 0; i < spaces.length; i++)				{					var staticLayer:ViewportBaseLayer = spaces[i].viewport.containerSprite;										var allObjects:Array = spaces[i].scene.objects as Array;					var numObjects:int = allObjects.length;					var allMaterials:Array = new Array();					for ( var j:int=0; j < numObjects; j++ )					{						var object:DisplayObject3D = DisplayObject3D( allObjects[ j ] );												var material:MaterialObject3D;												if (object.materials)						{/// obj.materials is the materialsList							for each( material in object.materials.materialsByName )							{								if ( material is MovieMaterial && (material as MovieMaterial).animated )								{									// put do3d in animated continuously rendering animatedLayer									if ( ! animatedLayerCreated )									{										animatedLayer = spaces[i].viewport.getChildLayer( object, true, false );																				animatedLayerCreated = true;									}									else									{										animatedLayer.addDisplayObject3D( object, false);									}									if ( staticLayer.hasDisplayObject3D(object) )									{										staticLayer.removeDisplayObject3D( object );									}								}								else								{									// put do3d in static layer which only renders with user input (camera motion)									staticLayer.addDisplayObject3D( object, false);									if (animatedLayer)									{										if ( animatedLayer.hasDisplayObject3D(object) )										{											animatedLayer.removeDisplayObject3D( object );										}									}								}																// break out of materials list loop								break;							}						}						else 						{// obj.material is the material							material = object.material;														if ( material is MovieMaterial && (material as MovieMaterial).animated )							{								// put do3d in animated continuously rendering animatedLayer								if ( ! animatedLayerCreated )								{									animatedLayer = spaces[i].viewport.getChildLayer( object, true, false );																		animatedLayerCreated = true;								}								else								{									animatedLayer.addDisplayObject3D( object, false);								}								if ( staticLayer.hasDisplayObject3D(object) )								{									staticLayer.removeDisplayObject3D( object );								}							}							else							{								// put do3d in static layer which only renders with user input (camera motion)								staticLayer.addDisplayObject3D( object, false);								if (animatedLayer)								{									if ( animatedLayer.hasDisplayObject3D(object) )									{									animatedLayer.removeDisplayObject3D( object );									}								}							}						}					}				}				if ( animatedLayer )				{					// render the animated layer.					for (i = 0; i < spaces.length; i++)					{						BasicRenderEngine(spaces[i].renderer).renderLayers						( 							Scene3D(spaces[i].scene), 							Camera3D(spaces[i].camera), 							Viewport3D(spaces[i].viewport),							[ animatedLayer ]						);					}				}								// end else render animated objects			}		}								private function interactionScene3DEventHandler(e:InteractiveScene3DEvent=null):void		{			var name:String = e.target.name;						trace("PS:" + interactionEquivalents[e.type] + " at " + name );						execute( settings..*.(hasOwnProperty("@id") && @id == name).attribute( interactionEquivalents[e.type] ).toString() );		}		private function mouseEventHandler(e:MouseEvent=null):void		{			//trace("mouse event", e.target.name, e.type);						var name:String = e.target.name;									execute( settings..*.(hasOwnProperty("@id") && @id == name).attribute( interactionEquivalents[e.type] ).toString() );					}				private function cursorHandler(e:InteractiveScene3DEvent):void		{			switch (e.type)			{				case (InteractiveScene3DEvent.OBJECT_OVER):					dispatchBroadcast(BroadcastEvent.HIDE_CURSOR);					//parent.dispatchEvent( new BroadcastEvent(BroadcastEvent.HIDE_CURSOR) );					Sprite( getSpaceByName(currentSpace).viewport ).buttonMode = true;					Sprite( getSpaceByName(currentSpace).viewport ).useHandCursor = true;										break;				case (InteractiveScene3DEvent.OBJECT_OUT):					//parent.dispatchEvent( new BroadcastEvent(BroadcastEvent.SHOW_CURSOR) );					dispatchBroadcast(BroadcastEvent.SHOW_CURSOR);					Sprite( getSpaceByName(currentSpace).viewport ).buttonMode = false;					Sprite( getSpaceByName(currentSpace).viewport ).useHandCursor = false;										break;			}		}				private function tooltipHandler(e:InteractiveScene3DEvent):void		{			switch (e.type)			{				case (InteractiveScene3DEvent.OBJECT_OVER):					var objName:String = e.target.name.toString();					dispatchBroadcast					(						BroadcastEvent.SHOW_TOOLTIP, 						"name="+objName, 						"tooltip="+settings..*.(hasOwnProperty("@id") && @id == objName).attribute( "tooltip" )					);					break;				case (InteractiveScene3DEvent.OBJECT_OUT):					dispatchBroadcast(BroadcastEvent.HIDE_TOOLTIP);					break;			}		}		//functions called by XML code hooks				public function dispatchBroadcast(type:String, ... args):void		{			var obj:Object = new Object();						var len:int = args.length;			for (var i:int=0; i<len; i++)			{				var arr:Array = args[i].split("=");				obj[arr[0]] = arr[1];			}			if (moduleLoader)				moduleLoader.dispatchEvent( new BroadcastEvent(type, obj) );		}				public function keyDown(direction:String):void		{			trace("PS: go:"+direction);						var e:KeyboardEvent = new KeyboardEvent(KeyboardEvent.KEY_DOWN);						e.keyCode = Keyboard[direction.toUpperCase()]						//stage.dispatchEvent(e)			keyDownEvent(e);		}		public function keyUp(direction:String):void		{						trace("PS: stop:"+direction);						var e:KeyboardEvent = new KeyboardEvent(KeyboardEvent.KEY_UP);						e.keyCode = Keyboard[direction.toUpperCase()]						//stage.dispatchEvent(e)			keyUpEvent(e);		}				public function toggleFullscreen():void		{			switch(stage.displayState) 			{				case "normal":					stage.displayState = "fullScreen";    					break;				case "fullScreen":				default:				stage.displayState = "normal";    					break;			}		}				public function toggleAutorotator():void		{			trace("PS: toggleAutorotator");						if (isAutorotating)			{				autorotatorOn = false;			}			else			{				startAutorotatorNow();			}		}				public function tween(str:String):void		{			trace("PS:tween:"+str);			//$obj.property over $time seconds $direction $endvalue using $easingFunction [then do $scope.function]						var o:Object = new Object();						var pieces:Array = str.split(" ");						var targetStr:String;			var targetObj:Object;			var property:String;			var targetGlob:String = pieces[0];				var targetArr:Array = targetGlob.split(".");				if (targetArr.length == 2)				{					targetStr = targetArr[0];					property = targetArr[1];				}				else				{					if (targetArr[0] == "lastSpace")					{						targetObj = getSpaceByName( lastSpace )[ targetArr[1] ];					}					else if(targetArr[0] == "currentSpace")					{						targetObj = getSpaceByName( currentSpace )[ targetArr[1] ];					}					else if(targetArr[0] == "loadingSpace")					{						targetObj = getSpaceByName( loadingSpace )[ targetArr[1] ];					}					else					{						targetObj = getSpaceByName( targetArr[0] )[ targetArr[1] ];					}										property = targetArr[2];				}								if (targetStr == "allCameras" || targetObj is Camera3D)				{					if (property == "pan") { property = "rotationY"; }					if (property == "tilt") { property = "rotationX"; }					if (property == "roll") { property = "rotationZ"; }				}			var direction:String = pieces[1];			var endValue:* = pieces[2];			endValue = (endValue.indexOf("'") == -1) ? Number(endValue) : String( endValue.substring(1,pieces[2].lastIndexOf("'")) ) ;				o[property] = endValue;						// pieces[3] = "over"			var time:Number = Number( pieces[4] );			// pieces[5] = "seconds"						// pieces[6] = "using"			var easingGlob:String = pieces[7]  || "Expo.easeOut"; 							var easingArr:Array = easingGlob.split(".");				var easeClass:String = easingArr[0];				var easeFunction:String = easingArr[1];			// pieces[8] = "then"			// pieces[9] = "do"			var afterGlob:String = pieces[10] || ""; trace(afterGlob);			if (afterGlob != "")			{				o.onComplete = execute;				o.onCompleteParams = [afterGlob];			}						var ec:Class;			var ef:Function;			if ( getDefinitionByName("gs.easing."+easeClass) )			{				ec = getDefinitionByName("gs.easing."+easeClass) as Class;				ef = ec.hasOwnProperty(easeFunction) ? ec[easeFunction] : ec.easeOut; 			}			else			{				trace("PS: tween err: can't find the given tween class, using default");				ec = getDefinitionByName("gs.easing.Expo") as Class;				ef = ec.easeOut;			}			o.ease = ef as Function;			o.overwrite = false;						// camera and viewport are specials, otherwise it will use getDisplayObject3dByName()			if (targetStr)			{				var i:int;				switch (targetStr)				{					case ("allCameras"):						dirtyWorld();						o.onUpdate = dirtyWorld;						for (i=0; i < spaces.length; i++)						{							var cam:Camera3D = Camera3D(spaces[i].camera);							TweenLite[direction].call(TweenLite, cam, time, o ); 						}						break;					case ("allViewports"):						for (i=0; i < spaces.length; i++)						{							var vp:Viewport3D = Viewport3D(spaces[i].viewport);							TweenLite[direction].call(TweenLite, vp, time, o ); 						}						break;					default:						dirtyWorld();						o.onUpdate = dirtyWorld;						TweenLite[direction].call(TweenLite, getDisplayObject3dByName(targetStr), time, o )						break;								}			}			else if(targetObj)			{				if (targetObj is Camera3D)				{					dirtyWorld();											TweenLite[direction].call(TweenLite, Camera3D(targetObj), time, o ); 				}				else if (targetObj is Viewport3D)				{					TweenLite[direction].call(TweenLite, Viewport3D(targetObj), time, o ); 				}			}		}				private function dirtyWorld():void		{			_worldDirty = true;		}		// 		public function set(str:String):void// 		{// 			trace("PS: set: ", str);// 			// 			var leftSide:String = str.slice(0, str.indexOf("=") );// 			// 			var rightSide:String = str.slice( str.indexOf("=")+1, str.length );// 			// 			var leftArray:Array = leftSide.split(".");// 			// 			var rightArray:Array = rightSide.split(",");// 			// 			var rightObject:Object = new Object();// 			// 			for (var i:int=0; i< rightArray.length; i++)// 			{// 				var name:String = rightArray[i].slice(0, rightArray[i].indexOf(":") );// 				var value:String = rightArray[i].slice(rightArray[i].indexOf(":")+1 );// 				// 				rightObject[name] = value;// 			}// 			// 			// 		}				///  This function is deprecated// 		public function loadSpaceAndInterface(name:String):void// 		{// 			trace("PS: loadSpaceAndInterface:"+name); // 			// 			if (bulkLoader.isRunning)// 			{// 				bulkLoader.removeAll();// 			}// 			// 			for each (var xml:XML in findXMLNode(name).children() )// 			{// 				for each (var mat:XML in xml.file)// 				{// 					bulkLoader.add(mat.toString(), { type:"image", weight: (mat.@weight || 10) });// 				// 					if (xml.name().localName.toString() != "bitmap")// 					{// 						bulkLoader.get(mat.toString()).addEventListener(Event.COMPLETE, onSingleItemLoaded, false, 100, true);// 					}// 				}// 			}// 			// 			loadingSpace = name;// 			// 			bulkLoader.start();// 			// 		}								public function loadSpace(name:String):void		{			trace("PS: loadSpace:"+name);						var wait:Boolean = false;						if (bulkLoader.isRunning)			{				bulkLoader.removeAll();			}						var nodeToLoad:XML = findXMLNode(name);						for each (var mat:XML in nodeToLoad..file)			{ 				bulkLoader.add(mat.toString(), { type:"image", weight: (mat.@weight || 10) });								bulkLoader.get(mat.toString()).addEventListener(Event.COMPLETE, onSingleItemLoaded, false, 100, true);								wait = true;			}						for each (var tile:XML in nodeToLoad..tile)			{ 				bulkLoader.add(tile.toString(), { type:"image", weight: (tile.@weight || 10) });								wait = true;			}						qtvrCount = 0;						for each (var mov:XML in nodeToLoad..mov)			{				bulkLoader.add(mov.toString(), { type:"xml", weight: (mov.@weight || 10) });								bulkLoader.get(mov.toString()).addEventListener(Event.COMPLETE, qtvrXMLLoaded, false, 100, true);								qtvrCount += 1;								wait = true;			}						loadingSpace = name;						if (wait)				bulkLoader.start();			else				onAllLoaded();					}				public function removeLastSpace():void		{			if (viewports.numChildren > 1 )			{				trace("PS: removeLastSpace:"+lastSpace);								viewports.removeChild( viewports.getChildByName( lastSpace ) );								var spaceToRemove:Object = getSpaceByName(lastSpace);								spaceToRemove["viewport"].destroy();								var objects:Array = spaceToRemove.scene.objects;				var len:int = objects.length;				for ( var j:int=0; j < len; j++ )				{					var obj:DisplayObject3D = objects[ j ];										if (obj.materials)					{						for each(  var mo3d:MaterialObject3D in obj.materials.materialsByName )						{							if (mo3d is BitmapMaterial)							{								BitmapMaterial(mo3d).destroy();							}							else { mo3d.destroy(); }						}					}					else					{ // object has only one material accessed this way:						var mat:MaterialObject3D = obj.material;						if (mat is BitmapMaterial)						{							BitmapMaterial(mat).destroy();						}						else { mat.destroy(); }					}										obj = null;				}								spaceToRemove.renderer.destroy();								spaceToRemove.scene = null;								spaceToRemove.camera = null;								if (spaceToRemove.stats)					spaceToRemove.stats = null;								spaces.splice(spaces.indexOf(spaceToRemove), 1);								spaceToRemove = null;							}			else trace("PS: removeLastSpace: there is no last space to remove"); 		}				private function instantiateNewSpace():int		{			spaces.push( new Object() );						var idx:uint = spaces.length-1;						//Viewport3D(viewportWidth:Number = 640, viewportHeight:Number = 480, autoScaleToStage:Boolean = false, interactive:Boolean = false, autoClipping:Boolean = true, autoCulling:Boolean = true)			var viewport:Viewport3D = new Viewport3D( 640, 480, true, false, true, true);						viewport.name = currentSpace;						spaces[idx].viewport = viewport;						var scene:Scene3D = new Scene3D();						spaces[idx].scene = scene;						var camera:Camera3D = new Camera3D();			camera.x = 0;			camera.y = 0;			camera.z = 0;						var vp:Rectangle = new Rectangle();			vp.width = viewport.viewportWidth;			vp.height = viewport.viewportHeight;			camera.update(vp);						spaces[idx].camera = camera;						var renderer:BasicRenderEngine = new BasicRenderEngine();						spaces[idx].renderer = renderer;						spaces[idx].name = currentSpace;						if ( stringToBoolean(settings.spaces.@statistics) || false )			{				var stats:StatsView = new StatsView( spaces[idx].renderer );							spaces[idx].stats = stats;							viewport.addChild(stats);			}						return idx;		}				public function getSpaceByName(name:String):Object		{			var i:int = 0;						while (i<spaces.length)			{				if (spaces[i].name == name) 				{ 					return spaces[i]; 				}				i++			}			return null;		}				public function getDisplayObject3dByName(name:String):DisplayObject3D		{			for (var i:int = 0; i < spaces.length; i++)			{				var objs:Array = spaces[i].scene.objects as Array;				var num:int = objs.length;				for ( var j:int=0; j < num; j++ )				{					var obj:DisplayObject3D = DisplayObject3D(objs[ j ]);										if (obj.name == name) 					{						return obj;					}				}			}			return null;		}						///////////////////////////////////////////////////////////		// CAMERA CONTROLLER				private var startPoint:Point = new Point( 0,0 );				private var deltaPan:Number = 0;		private var deltaTilt:Number = 0;		public var sensitivity:Number = 60;		public var friction:Number = 0.3;		public var threshold:Number = 0.0001;		public var zoomIncrement:Number = 0.2;		public var keyIncrement:Number = 75;				private var autorotatorTimer:Timer;		private var _autorotatorDelay:Number = 15000;		private var _autorotatorOn:Boolean = true;				private var resting:Boolean = true;				private var mouseIsDown:Boolean = false;		private var keyIsDown:Boolean = false;				public var isAutorotating:Boolean = false;				private var up:Boolean = false;		private var down:Boolean = false;		private var left:Boolean = false;		private var right:Boolean = false;		private var zoomin:Boolean = false;		private var zoomout:Boolean = false;				private function initCameraController( autorotator:Boolean = true, autorotatorDelay:Number = 15000 ):void		{			//this._parent = _parent;			this.autorotatorDelay = autorotatorDelay			stage.addEventListener( MouseEvent.MOUSE_DOWN,mouseDownEvent, false, 100, true );			stage.addEventListener( MouseEvent.MOUSE_UP,mouseUpEvent, false, 0, true );			stage.addEventListener( Event.DEACTIVATE, mouseUpEvent, false, 0, true );			stage.addEventListener( KeyboardEvent.KEY_DOWN, keyDownEvent, false, 100, true );			stage.addEventListener( KeyboardEvent.KEY_UP, keyUpEvent, false, 0, true);						// start the autorotator			_autorotatorOn = autorotator;			if (autorotator)			{				setUpAutorotator();			}		}				private function isApplication(target:Object):Boolean		{			if ( ApplicationDomain.currentDomain.hasDefinition("mx.core.Application") )			{				if ( target is Class( ApplicationDomain.currentDomain.getDefinition("mx.core.Application") ) )				{					return true;				}			}						return false;		}				protected function mouseDownEvent( event:MouseEvent ):void		{ 			if ( (event.target is ViewportBaseLayer) || (event.target is ViewportLayer) || isApplication(event.target) )			{				mouseIsDown = true;								startPoint.x = stage.mouseX;				startPoint.y = stage.mouseY;								changeQuality("accelerating");								stopAutorotatorNow();			}		}				protected function keyDownEvent( event:KeyboardEvent ):void		{ 			switch( event.keyCode )			{			case Keyboard.UP:				up = true; 				startKeyMovement();			break;				case Keyboard.DOWN:				down = true;				startKeyMovement();			break;				case Keyboard.LEFT:				left = true;				startKeyMovement();			break;				case Keyboard.RIGHT:				right = true;				startKeyMovement();			break;			case Keyboard.SHIFT:				zoomin = true;				startKeyMovement();			break;			case Keyboard.CONTROL:				zoomout = true;				startKeyMovement();			break;			}		}				protected function startKeyMovement():void		{			stopAutorotatorNow();						keyIsDown = true;						changeQuality("accelerating");		}						protected function mouseUpEvent( event:Event ):void		{			mouseIsDown = false;						changeQuality("decelerating");		}				protected function keyUpEvent(event:KeyboardEvent):void		{			switch( event.keyCode )				{				case Keyboard.UP:					up = false;				break;					case Keyboard.DOWN:					down = false;				break;					case Keyboard.LEFT:					left = false;				break;					case Keyboard.RIGHT:					right = false;				break;				case Keyboard.SHIFT:					zoomin = false;				break;				case Keyboard.CONTROL:					zoomout = false;				break;				}			if ( !up && !down && !left && !right && !zoomin && !zoomout )			{				keyIsDown = false;								changeQuality("decelerating");			}		}				public function set autorotatorDelay(autorotatorDelay:Number):void		{			if (autorotatorTimer != null)			{				autorotatorTimer.delay = autorotatorDelay;			}			this._autorotatorDelay = autorotatorDelay;		}		public function get autorotatorDelay():Number		{			return _autorotatorDelay;		}				private function setUpAutorotator():void		{			autorotatorTimer = new Timer(autorotatorDelay);			autorotatorTimer.addEventListener("timer", startAutorotatorNow, false, 0, true);			restartAutorotatorTimer();		}				public function restartAutorotatorTimer():void		{			if (_autorotatorOn)			{				stopAutorotatorNow();				autorotatorTimer.start();			}		}				public function startAutorotatorNow(e:TimerEvent=null):void		{			if (autorotatorTimer)			{				autorotatorTimer.stop();				autorotatorTimer.reset();			}									isAutorotating = true;		}				public function stopAutorotatorNow():void		{			if (autorotatorTimer)			{				autorotatorTimer.stop();				autorotatorTimer.reset();			}						isAutorotating = false;		}				public function set autorotatorOn(value:Boolean):void		{			_autorotatorOn = value;			if (value)			{				restartAutorotatorTimer();			}			else			{				stopAutorotatorNow();			}		}				public function get autorotatorOn():Boolean		{			return _autorotatorOn;		}								/////////////////////////////////////////////////////																														//tools		private function pinToSphere(r:Number, p:Number, t:Number):Number3D		{			var pr:Number	= (-1*(p - 90)) * (Math.PI/180); 			var tr:Number	= t * (Math.PI/180);			var xc:Number = r * Math.cos(pr) * Math.cos(tr);			var yc:Number = r * Math.sin(tr);			var zc:Number = r * Math.sin(pr) * Math.cos(tr);						var n:Number3D = new Number3D();			n.x = xc;			n.y = yc;			n.z = zc;			return n;		}				// XML Tools		private function XMLCodeHook(name:String, checkCurrentSceneFirst:Boolean=true):void		{				var attr:String;						if (checkCurrentSceneFirst)			{				attr = findValueInXML(name, String, "");			}			else attr = settings.spaces.attribute(name).toString();						if ( attr != null && attr != "")			{				execute(attr);			}		}				public function execute(attr:String):void		{						if ( attr != null && attr != "")			{				trace("PS: execute: "+attr);								var lines:Array = attr.split(";");				for (var i:uint = 0; i < lines.length; i++)				{						var func:String;					var colonIdx:int = lines[i].indexOf(":");					if ( colonIdx != -1 )					{						//var action:Array = lines[i].split(":");						func = lines[i].substring( 0, colonIdx );						func = StringUtil.trim(func);												var argStr:String = lines[i].substring( colonIdx+1 );						var args:Array = argStr.split(",");						for each (var s:String in args)						{							s = StringUtil.trim(s);						}												if( this.hasOwnProperty(func) )						{							(this[func] as Function).apply(this, args);						}						else if ( CustomActions )						{							if( CustomActions.hasOwnProperty(func) )							{								(CustomActions[func] as Function).apply(CustomActions, args);							}						}						else						{							executeXMLFunction(func);						}					}					else 					{						func = lines[i];						func = StringUtil.trim(func);						if( this.hasOwnProperty(func) )						{							(this[func] as Function).call(this);						}						else if ( CustomActions )						{							if( CustomActions.hasOwnProperty(func) )							{								(CustomActions[func] as Function).call(CustomActions);							}						}						else						{							executeXMLFunction(func);						}											}				}			}		}				private function executeXMLFunction(str:String):void		{			trace("PS: executeXMLFunction:"+str);						var strArr:Array = str.split(".");						var functionScope:String;			var functionName:String;			if (strArr.length != 2) 			{ // function is NOT identified by a scope, search each space then spaces.				functionName = findValueInXML( str, String, "" );				execute( functionName );			}			else			{				functionScope = strArr[0];				functionName = strArr[1];								var xmlFunction:String				if (functionScope == "spaces")				{					xmlFunction = settings.spaces.attribute( functionName )				}				else				{					var scope:XML = findXMLNode( functionScope );					xmlFunction = scope.@[functionName];				}								if (xmlFunction != "" && xmlFunction != null)					execute( xmlFunction );			}		}				// this is specifically for drop down controller components		public function getSpacesAndLabels():Array		{			var retArr:Array = new Array();			var node:XML;			var label:String;			var id:String;			var entry:Object = new Object();			for each (node in settings.spaces.*)			{				label = node.@label || node.@id;				id = node.@id;								entry.label = label;				entry.id = id;								retArr.push( entry );			}						return retArr;		}				//search in child node first, then in settings node		private function findXMLNode(name:String):XML		{			var node:XML;			for each (node in settings..*)			{				if (node.@id == name)				{					break;				}			}			if (node.@id == name)				return node;			else return null;		}				private function findValueInXML(name:String, ReturnClass:Class, def:*):*		{			// check the currentSpace node for the value first			var cs:XML = findXMLNode(currentSpace);			if (cs)			{				if ( cs.attribute(name).toString().length != 0 )				{					if ( ReturnClass != Boolean )					{ 						return ReturnClass( cs.attribute(name) );					}					else					{ 						return ReturnClass( stringToBoolean(cs.attribute(name) ) );					}				}			}			// check the spaces node next			if ( settings.spaces.attribute(name).toString().length != 0 )			{ 				if ( ReturnClass != Boolean )				{					return ReturnClass( settings.spaces.attribute(name) );				}				else				{					return ReturnClass( stringToBoolean(settings.spaces.attribute(name)) );				}			}			else return ReturnClass(def);		}				private function stringToBoolean(str:String):Boolean		{			var ret:Boolean;			ret = (str == "true") ? true : false;			return ret;		}				private var zExpo:Function = Expo.easeIn;		private var zBack:Function = Back.easeIn;		private var zBounce:Function = Bounce.easeIn;		private var zCirc:Function = Circ.easeIn;		private var zCubic:Function = Cubic.easeIn;		private var zElastic:Function = Elastic.easeIn;		private var zQuad:Function = Quad.easeIn;		private var zQuart:Function = Quart.easeIn;		private var zQuint:Function = Quint.easeIn;		private var zSine:Function = Sine.easeIn;	}}